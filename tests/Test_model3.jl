# Check the accruacy of the PeTab importer for a simple linear ODE;
#   x' = a - bx + cy; x(0) = 0 
#   y' = bx - cy - dy;  y(0) = 0
# where the model has a pre-equilibrium condition. That is he simulated data for 
# this ODE model is generated by starting from the steady state;
# x* = a / b + ( a * c ) / ( b * d )
# y* = a / d
# and when computing the cost in the PeTab importer the model is first simualted 
# to a steady state, and then the mian simulation matched against data is 
# performed.
# This test compares the ODE-solution, cost, gradient and hessian when 
# i) solving the ODE using the SS-equations as initial condition, and ii) when 
# first simulating the model to the steady state.
# Accruacy of both the hessian and gradient are strongly dependent on the tolerances 
# used in the TerminateSteadyState used to terminate steady state simulation.


using Distributions
using ModelingToolkit 
using DifferentialEquations
using DataFrames
using CSV 
using ForwardDiff
using ReverseDiff
using StatsBase
using Random
using LinearAlgebra
using Distributions
using Printf
using Ipopt
using Optim
using SciMLSensitivity
using Zygote


# Relevant PeTab structs for compuations 
include(joinpath(pwd(), "src", "PeTab_structs.jl"))

# Functions for solving ODE system 
include(joinpath(pwd(), "src", "Solve_ODE_model", "Solve_ode_model.jl"))

# PeTab importer to get cost, grad etc 
include(joinpath(pwd(), "src", "PeTab_importer", "Create_cost_grad_hessian.jl"))

# HyperCube sampling 
include(joinpath(pwd(), "src", "Optimizers", "Lathin_hypercube.jl"))

# For converting to SBML 
include(joinpath(pwd(), "src", "SBML", "SBML_to_ModellingToolkit.jl"))

# Optimizers 
include(joinpath(pwd(), "src", "Optimizers", "Set_up_Ipopt.jl"))
include(joinpath(pwd(), "src", "Optimizers", "Set_up_optim.jl"))


function getSolAlgebraicSS(peTabModel::PeTabModel, solver, tol::Float64, a::T1, b::T1, c::T1, d::T1) where T1<:Real

    # ODE solution with algebraically computed initial values (instead of ss pre-simulation)
    odeProb = ODEProblem(peTabModel.odeSystem, peTabModel.stateMap, (0.0, 9.7), peTabModel.paramMap, jac=true)
    odeProb = remake(odeProb, p = convert.(eltype(a), odeProb.p), u0 = convert.(eltype(a), odeProb.u0))
    solArray = Array{Union{OrdinaryDiffEq.ODECompositeSolution, ODESolution}, 1}(undef, 2)

    # Set model parameter values to ensure initial steady state 
    odeProb.p[5], odeProb.p[3], odeProb.p[1], odeProb.p[6] = a, b, c, d
    odeProb.u0[1] = a / b + ( a * c ) / ( b * d ) # x0
    odeProb.u0[2] = a / d # y0

    odeProb.p[4] = 2.0 # a_scale
    solArray[1] = solve(odeProb, solver, abstol=tol, reltol=tol)
    odeProb.p[4] = 0.5 # a_scale
    solArray[2] = solve(odeProb, solver, abstol=tol, reltol=tol)

    return solArray
end


function calcCostAlgebraic(paramVec, peTabModel, solver, tol)
    
    a, b, c, d = paramVec

    experimentalConditionsFile, measurementDataFile, parameterDataFile, observablesDataFile = readDataFiles(peTabModel.dirModel, readObs=true)
    measurementData = processMeasurementData(measurementDataFile, observablesDataFile) 

    solArrayAlg = getSolAlgebraicSS(peTabModel, solver, tol, a, b, c, d)
    logLik = 0.0
    for i in eachindex(measurementData.tObs)
        yObs = measurementData.yObsNotTransformed[i]
        t = measurementData.tObs[i]
        if measurementData.conditionId[i] == "defaultdouble"
            yMod = solArrayAlg[1](t)[1]
        else
            yMod = solArrayAlg[2](t)[2]
        end
        sigma = 0.04
        logLik += log(sigma) + 0.5*log(2*pi) + 0.5 * ((yObs - yMod) / sigma)^2
    end
    
    return logLik
end


function testOdeSol(peTabModel::PeTabModel, solver, tol; printRes=false)
   
    # Set values to PeTab file values 
    experimentalConditionsFile, measurementDataFile, parameterDataFile, observablesDataFile = readDataFiles(peTabModel.dirModel, readObs=true)
    measurementData = processMeasurementData(measurementDataFile, observablesDataFile) 
    paramData = processParameterData(parameterDataFile) 
    setParamToFileValues!(peTabModel.paramMap, peTabModel.stateMap, paramData)
    
    # Extract experimental conditions for simulations 
    simulationInfo = getSimulationInfo(measurementDataFile, measurementData, absTolSS=1e-12, relTolSS=1e-10)

    # Parameter values where to teast accuracy. Each column is a alpha, beta, gamma and delta
    # a, b, c, d
    paramMat = reshape([1.0, 2.0, 3.0, 4.0,
                        0.1, 0.2, 0.3, 0.4,
                        4.0, 3.0, 2.0, 1.0,
                        1.0, 1.0, 1.0, 1.0,
                        2.5, 7.0, 3.0, 3.0,], (4, 5))

    for i in 1:5    
        a, b, c, d = paramMat[:, i]        
        # Set parameter values for ODE
        peTabModel.paramMap[1] = Pair(peTabModel.paramMap[1].first, c)
        peTabModel.paramMap[3] = Pair(peTabModel.paramMap[3].first, b)
        peTabModel.paramMap[5] = Pair(peTabModel.paramMap[5].first, a)
        peTabModel.paramMap[6] = Pair(peTabModel.paramMap[6].first, d)

        prob = ODEProblem(peTabModel.odeSystem, peTabModel.stateMap, (0.0, 9.7), peTabModel.paramMap, jac=true)
        prob = remake(prob, p = convert.(Float64, prob.p), u0 = convert.(Float64, prob.u0))
        changeToExperimentalCondUse! = (pVec, u0Vec, expID) -> changeExperimentalCond!(pVec, u0Vec, expID, paramData, experimentalConditionsFile, peTabModel)
        
        # Solve ODE system with steady state simulation 
        solArray, success = solveOdeModelAllExperimentalCond(prob, changeToExperimentalCondUse!, simulationInfo, solver, tol, tol)

        # Solve ODE system with algebraic intial values 
        solArrayAlg = getSolAlgebraicSS(peTabModel, solver, tol, a, b, c, d)
        
        # Compare against analytical solution 
        sqDiff = 0.0
        for i in eachindex(solArray)
            solNum = solArray[i]
            solAlg = solArrayAlg[i]
            sqDiff += sum((Array(solNum) - Array(solAlg(solNum.t))).^2)
        end

        if sqDiff > 1e-6
            @printf("sqDiff = %.3e\n", sqDiff)
            @printf("Does not pass test\n")
            return false
        end

        if printRes == true
            @printf("sqDiff = %.3e\n", sqDiff)
        end
    end

    return true
end


function testCostGradHess(peTabModel::PeTabModel, solver, tol; printRes::Bool=false)

    solver = Rodas4P(autodiff=false)
    tol = 1e-12
    peTabOpt = setUpCostGradHess(peTabModel, solver, tol, absTolSS=1e-12, relTolSS=1e-10, sensealg=ForwardDiffSensitivity())
    calcCostAlg = (paramVec) -> calcCostAlgebraic(paramVec, peTabModel, solver, tol)

    Random.seed!(123)
    createCube(peTabOpt, 5)
    cube = Matrix(CSV.read(peTabOpt.pathCube, DataFrame))

    for i in 1:5

        paramVec = cube[i, :]

        # Evaluate cost 
        costPeTab = peTabOpt.evalF(paramVec)
        costAlg = calcCostAlg(paramVec)
        sqDiffCost = (costPeTab - costAlg)^2
        if sqDiffCost > 1e-4
            @printf("sqDiffCost = %.3e\n", sqDiffCost)
            @printf("Does not pass test on cost\n")
            return false
        end

        # Evaluate cost for Zygote 
        costZygote = peTabOpt.evalFZygote(paramVec)
        sqDiffCostZygote = (costPeTab - costAlg)^2
        if sqDiffCostZygote > 1e-4
            @printf("sqDiffCostZygote = %.3e\n", sqDiffCostZygote)
            @printf("Does not pass test on cost\n")
            return false
        end

        # Evaluate gradient 
        gradAlg = ForwardDiff.gradient(calcCostAlg, paramVec)
        grad = zeros(4)
        peTabOpt.evalGradF(grad, paramVec)
        sqDiffGrad = sum((grad - gradAlg).^2)
        if sqDiffGrad > 1e-4
            @printf("sqDiffGrad = %.3e\n", sqDiffGrad)
            @printf("Does not pass test on gradient\n")
            return false
        end

        # Evaluate gradient via Zygote 
        gradZygote = Zygote.gradient(peTabOpt.evalFZygote, paramVec)[1]
        sqDiffGradZygote = sum((gradZygote - gradAlg).^2)
        if sqDiffGradZygote > 1e-4
            @printf("sqDiffGradZygote = %.3e\n", sqDiffGradZygote)
            @printf("Does not pass test on gradient\n")
            return false
        end

        # Evaluate hessian 
        hessAlg = ForwardDiff.hessian(calcCostAlg, paramVec)
        hess = zeros(4, 4); peTabOpt.evalHess(hess, paramVec)
        sqDiffHess = sum((hessAlg - hess).^2)
        if sqDiffHess > 1e-3
            @printf("sqDiffHess = %.3e\n", sqDiffHess)
            @printf("Does not pass test on hessian\n")
            return false
        end
                
        if printRes == true
            @printf("sqDiffCost = %.3e\n", sqDiffCost)
            @printf("sqDiffGrad = %.3e\n", sqDiffGrad)
            @printf("sqDiffHess = %.3e\n", sqDiffHess)
            @printf("sqDiffCostZygote = %.3e\n", sqDiffCostZygote)
            @printf("sqDiffGradZygote = %.3e\n", sqDiffGradZygote)
        end
    end

    return true 
end


peTabModel = setUpPeTabModel("Test_model3", pwd() * "/tests/Test_model3/", forceBuildJlFile=true)
a = 1
passTest = testOdeSol(peTabModel, Rodas4P(), 1e-12, printRes=true)
if passTest == true
    @printf("Passed test for ODE solution\n")
else
    @printf("Did not pass test for ODE solution\n")
end

passTest = testCostGradHess(peTabModel, Rodas4P(), 1e-12, printRes=true)
if passTest == true
    @printf("Passed test for cost, gradient and hessian\n")
else
    @printf("Did not pass test for cost, gradient and hessian\n")
end

peTabOpt = setUpCostGradHess(peTabModel, Rodas5P(), 1e-12, sensealg = ForwardDiffSensitivity(), 
                             adjSolver=Rodas5P(), adjTol=1e-12, 
                             adjSensealg=InterpolatingAdjoint(autojacvec=ReverseDiffVJP(true)))
a = 1                             
gradFor = zeros(length(peTabOpt.paramVecTransformed))

peTabOpt.evalF(peTabOpt.paramVecTransformed)
@elapsed peTabOpt.evalGradF(gradFor, peTabOpt.paramVecTransformed)
prob = peTabOpt.evalF.simulationInfo.solArray[1].prob
probUse = remake(prob, tspan=(0.0, 100))
pUse = probUse.p

myF = (p) -> Array(solve(probUse, Rodas5(autodiff=false), abstol=1e-8, reltol=1e-8, p=p, dense=false, sensealg=InterpolatingAdjoint(autodiff=false, autojacvec=false)))[:,end]
y, ybar = Zygote.pullback(myF, pUse)
@elapsed foo1 = ybar([1.0, 0.0])

ssProb = SteadyStateProblem(prob)
ySS, ybarSS = Zygote.pullback((p) -> solve(ssProb, DynamicSS(Rodas5()), abstol=1e-8, reltol=1e-8, p=p, sensealg=SteadyStateAdjoint(autojacvec=ReverseDiffVJP(true)))[:], pUse)
@elapsed foo2 = ybarSS([1.0, 0.0])


myF = (p) -> Array(solve(probUse, Rodas5(autodiff=false), abstol=1e-8, reltol=1e-8, p=p, dense=false, callback=TerminateSteadyState(), sensealg=SteadyStateAdjoint()))[:,end]
y, ybar = Zygote.pullback(myF, pUse)


hej = solve(prob, Rodas5(), abstol=1e-8, reltol=1e-8, callback=TerminateSteadyState(), dense=false)

using StaticArrays

u0M = SVector{length(prob.u0), Float64}(prob.u0) 
pM = SVector{length(prob.p), Float64}(prob.p) 

odeProb = ODEProblem{false}(peTabModel.odeSystem, 
                            peTabModel.stateMap, 
                            (0.0, 5e3), 
                            peTabModel.paramMap, 
                            jac=true)
probM = remake(odeProb, p = pM, u0=u0M, tspan=(@SVector [0.0, 1.0]))

b1 = @benchmark solve(prob, Rodas5(), abstol=1e-8, reltol=1e-8)
b2 = @benchmark solve(probM, Rodas5(), abstol=1e-8, reltol=1e-8)


solver = Rodas4P()
tol = 1e-8

# Process PeTab files into type-stable Julia structs 
experimentalConditionsFile, measurementDataFile, parameterDataFile, observablesDataFile = readDataFiles(peTabModel.dirModel, readObs=true)
parameterData = processParameterData(parameterDataFile)
measurementData = processMeasurementData(measurementDataFile, observablesDataFile) 
simulationInfo = getSimulationInfo(measurementDataFile, measurementData)

# Indices for mapping parameter-estimation vector to dynamic, observable and sd parameters correctly when calculating cost
paramEstIndices = getIndicesParam(parameterData, measurementData, peTabModel.odeSystem, experimentalConditionsFile)
    
# Set up potential prior for the parameters to estimate 
priorInfo::PriorInfo = getPriorInfo(paramEstIndices, parameterDataFile)

# Set model parameter values to those in the PeTab parameter data ensuring correct value of constant parameters 
setParamToFileValues!(peTabModel.paramMap, peTabModel.stateMap, parameterData)

# The time-span 5e3 is overwritten when performing actual forward simulations 
odeProb = ODEProblem(peTabModel.odeSystem, peTabModel.stateMap, (0.0, 5e3), peTabModel.paramMap, jac=true, sparse=false)
odeProb = remake(odeProb, p = convert.(Float64, odeProb.p), u0 = convert.(Float64, odeProb.u0))

# Functions to map experimental conditions and parameters correctly to the ODE model 
changeToExperimentalCondUse! = (pVec, u0Vec, expID, dynParamEst) -> changeExperimentalCondEst!(pVec, u0Vec, expID, dynParamEst, peTabModel, paramEstIndices)
changeModelParamUse! = (pVec, u0Vec, paramEst) -> changeModelParam!(pVec, u0Vec, paramEst, paramEstIndices, peTabModel)

# Set up function which solves the ODE model for all conditions and stores result 
solveOdeModelAllCondAdjUse! = (solArrayArg, odeProbArg, dynParamEst, expIDSolveArg) -> solveOdeModelAllExperimentalCond!(solArrayArg, odeProbArg, dynParamEst, changeToExperimentalCondUse!, simulationInfo, solver, tol, tol, denseSol=true, expIDSolve=expIDSolveArg)

paramVecEst = peTabOpt.paramVecTransformed
paramIndices = paramEstIndices
dynamicParamEst = paramVecEst[paramIndices.iDynParam]
obsParEst = paramVecEst[paramIndices.iObsParam]
sdParamEst = paramVecEst[paramIndices.iSdParam]
noneDynParamEst = paramVecEst[paramIndices.iNonDynParam]

dynamicParamEstUse = transformParamVec(dynamicParamEst, paramIndices.namesDynParam, parameterData)
sdParamEstUse = transformParamVec(sdParamEst, paramIndices.namesSdParam, parameterData)
obsParEstUse = transformParamVec(obsParEst, paramIndices.namesObsParam, parameterData)
nonDynParamEstUse = transformParamVec(noneDynParamEst, paramIndices.namesNonDynParam, parameterData)

odeProbUse = remake(odeProb, p = convert.(eltype(dynamicParamEstUse), odeProb.p), u0 = convert.(eltype(dynamicParamEstUse), odeProb.u0))
changeModelParamUse!(odeProbUse.p, odeProbUse.u0, dynamicParamEstUse)
success = solveOdeModelAllCondAdjUse!(simulationInfo.solArrayGrad, odeProbUse, dynamicParamEstUse, ["all"])

preEqSol = simulationInfo.solArrayPreEq[1]
probSSPullback = remake(preEqSol.prob, tspan=(0.0, preEqSol.t[end]))
ssVal, yBarSS = Zygote.pullback((p) -> solve(probSSPullback, solver, p=p, abstol=tol, reltol=tol, sensealg=QuadratureAdjoint(autodiff=false, autojacvec=false))[:, end], preEqSol.prob.p)

sensealg = QuadratureAdjoint(autojacvec=false)
gradAdj = zeros(4)

for j in 1:2

    sol = simulationInfo.solArrayGrad[j]
    conditionID = simulationInfo.conditionIdSol[j]

    iGroupedTObs = measurementData.iGroupedTObs[conditionID]
    # Pre allcoate vectors needed for computations 
    dYmodDu = zeros(Float64, length(sol.prob.u0))
    dSdDu = zeros(Float64, length(sol.prob.u0))
    dYmodDp = zeros(Float64, length(sol.prob.p))
    dSdDp = zeros(Float64, length(sol.prob.p))

    # Functions needed by the lower level interface 
    calcDgDuDiscrete = (out, u, p, t, i) -> begin calcdGd_Discrete(out, u, p, t, i, iGroupedTObs, 
                                                                measurementData, parameterData, 
                                                                paramIndices, peTabModel, 
                                                                dynamicParamEstUse, sdParamEstUse, obsParEstUse, nonDynParamEstUse, 
                                                                dYmodDu, dSdDu, calcdGdU=true)
                                            end
    calcDgDpDiscrete = (out, u, p, t, i) -> begin calcdGd_Discrete(out, u, p, t, i, iGroupedTObs, 
                                                                measurementData, parameterData, 
                                                                paramIndices, peTabModel, 
                                                                dynamicParamEstUse, sdParamEstUse, obsParEstUse, nonDynParamEstUse, 
                                                                dYmodDp, dSdDp, calcdGdU=false)
                                                                                            end
                                                                                        
    # Time points for which we have observed data 
    tSaveAt = measurementData.tVecSave[conditionID]
    du, dp = adjoint_sensitivities(sol, 
                                Rodas4P(),
                                dgdp_discrete=nothing,
                                dgdu_discrete=calcDgDuDiscrete, 
                                t=tSaveAt, 
                                sensealg=sensealg, 
                                abstol=tol, 
                                reltol=tol)

    # Technically we can pass calcDgDpDiscrete above to dgdp_discrete. However, odeProb.p often contain 
    # constant parameters which are not a part ode the parameter estimation problem. Sometimes 
    # the gradient for these evaluate to NaN (as they where never thought to be estimated) which 
    # results in the entire gradient evaluating to NaN. Hence, we perform this calculation outside 
    # of the lower level interface. 
    dgDpOut = zeros(Float64, length(sol.prob.p))
    for i in eachindex(tSaveAt)                                                                                        
        calcDgDpDiscrete(dgDpOut, sol(tSaveAt[i]), sol.prob.p, tSaveAt[i], i)
        dp .+= dgDpOut'
    end

    # Compute initial sensitives and adjust gradient accordingly  
    sMatAtT0 = ForwardDiff.jacobian(peTabModel.evalU0, sol.prob.p)
    gradTot = dp .+ du'*sMatAtT0

    # Compensate for initial values 
    gradTot[:] .+= yBarSS(du)[1]

    # Thus far have have computed dY/dθ, but for parameters on the log-scale we 
    # want dY/dθ_log. We can adjust via;
    # dY/dθ_log = log(10) * θ * dY/dθ'
    gradAdj .+= transformParamVecGrad(gradTot[paramIndices.mapDynParEst.iDynParamInSys], dynamicParamEstUse, paramIndices.namesDynParam, parameterData)
end

gradFor = zeros(4)
peTabOpt.evalGradF(gradFor, peTabOpt.paramVecTransformed)
probSSPullback = remake(probSSPullback, tspan=(0.0, 15.0))

condition(u,t,integrator) = t== 15.0
affect!(integrator) = integrator.p[4] = 2.0
cb = DiscreteCallback(condition,affect!)
senseEnd = (ForwardDiff.jacobian((p) -> solve(probSSPullback, solver, p=p, abstol=tol, reltol=tol, callback=cb, tstops=[15.0])[:, end], preEqSol.prob.p))

yBarSS(du)
du' * senseEnd

senseProb = ODEForwardSensitivityProblem(probSSPullback.f, probSSPullback.u0, (0.0, 15.0), probSSPullback.p)
sol = solve(senseProb)#,  callback=cb, tstops=[15.0])

tmp = collect(extract_local_sensitivities(sol, 15.0)[2])
for i in eachindex(tmp)
senseFirst = zeros(2, 6)
