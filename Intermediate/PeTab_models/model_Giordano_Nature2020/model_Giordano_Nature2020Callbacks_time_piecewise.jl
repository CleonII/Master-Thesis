function getCallbacks_model_Giordano_Nature2020()
	cb_delta_bool10 = DiscreteCallback(condition_delta_bool10, affect_delta_bool10!, save_positions=(false, false))

	cb_beta_bool3 = DiscreteCallback(condition_beta_bool3, affect_beta_bool3!, save_positions=(false, false))

	cb_alpha_bool12 = DiscreteCallback(condition_alpha_bool12, affect_alpha_bool12!, save_positions=(false, false))

	cb_alpha_bool4 = DiscreteCallback(condition_alpha_bool4, affect_alpha_bool4!, save_positions=(false, false))

	cb_epsilon_bool1 = DiscreteCallback(condition_epsilon_bool1, affect_epsilon_bool1!, save_positions=(false, false))

	cb_eta_bool5 = DiscreteCallback(condition_eta_bool5, affect_eta_bool5!, save_positions=(false, false))

	cb_eta_bool8 = DiscreteCallback(condition_eta_bool8, affect_eta_bool8!, save_positions=(false, false))

	cb_kappa_bool4 = DiscreteCallback(condition_kappa_bool4, affect_kappa_bool4!, save_positions=(false, false))

	cb_rho_bool6 = DiscreteCallback(condition_rho_bool6, affect_rho_bool6!, save_positions=(false, false))

	cb_delta_bool9 = DiscreteCallback(condition_delta_bool9, affect_delta_bool9!, save_positions=(false, false))

	cb_xi_bool7 = DiscreteCallback(condition_xi_bool7, affect_xi_bool7!, save_positions=(false, false))

	cb_rho_bool2 = DiscreteCallback(condition_rho_bool2, affect_rho_bool2!, save_positions=(false, false))

	cb_rho_bool3 = DiscreteCallback(condition_rho_bool3, affect_rho_bool3!, save_positions=(false, false))

	cb_kappa_bool7 = DiscreteCallback(condition_kappa_bool7, affect_kappa_bool7!, save_positions=(false, false))

	cb_zeta_bool8 = DiscreteCallback(condition_zeta_bool8, affect_zeta_bool8!, save_positions=(false, false))

	cb_mu_bool2 = DiscreteCallback(condition_mu_bool2, affect_mu_bool2!, save_positions=(false, false))

	cb_rho_bool1 = DiscreteCallback(condition_rho_bool1, affect_rho_bool1!, save_positions=(false, false))

	cb_nu_bool4 = DiscreteCallback(condition_nu_bool4, affect_nu_bool4!, save_positions=(false, false))

	cb_lam_bool4 = DiscreteCallback(condition_lam_bool4, affect_lam_bool4!, save_positions=(false, false))

	cb_delta_bool3 = DiscreteCallback(condition_delta_bool3, affect_delta_bool3!, save_positions=(false, false))

	cb_xi_bool5 = DiscreteCallback(condition_xi_bool5, affect_xi_bool5!, save_positions=(false, false))

	cb_alpha_bool6 = DiscreteCallback(condition_alpha_bool6, affect_alpha_bool6!, save_positions=(false, false))

	cb_zeta_bool7 = DiscreteCallback(condition_zeta_bool7, affect_zeta_bool7!, save_positions=(false, false))

	cb_xi_bool9 = DiscreteCallback(condition_xi_bool9, affect_xi_bool9!, save_positions=(false, false))

	cb_sigma_bool2 = DiscreteCallback(condition_sigma_bool2, affect_sigma_bool2!, save_positions=(false, false))

	cb_beta_bool2 = DiscreteCallback(condition_beta_bool2, affect_beta_bool2!, save_positions=(false, false))

	cb_beta_bool4 = DiscreteCallback(condition_beta_bool4, affect_beta_bool4!, save_positions=(false, false))

	cb_delta_bool1 = DiscreteCallback(condition_delta_bool1, affect_delta_bool1!, save_positions=(false, false))

	cb_xi_bool4 = DiscreteCallback(condition_xi_bool4, affect_xi_bool4!, save_positions=(false, false))

	cb_gamma_bool5 = DiscreteCallback(condition_gamma_bool5, affect_gamma_bool5!, save_positions=(false, false))

	cb_eta_bool6 = DiscreteCallback(condition_eta_bool6, affect_eta_bool6!, save_positions=(false, false))

	cb_eta_bool7 = DiscreteCallback(condition_eta_bool7, affect_eta_bool7!, save_positions=(false, false))

	cb_rho_bool7 = DiscreteCallback(condition_rho_bool7, affect_rho_bool7!, save_positions=(false, false))

	cb_zeta_bool5 = DiscreteCallback(condition_zeta_bool5, affect_zeta_bool5!, save_positions=(false, false))

	cb_gamma_bool4 = DiscreteCallback(condition_gamma_bool4, affect_gamma_bool4!, save_positions=(false, false))

	cb_eta_bool2 = DiscreteCallback(condition_eta_bool2, affect_eta_bool2!, save_positions=(false, false))

	cb_rho_bool10 = DiscreteCallback(condition_rho_bool10, affect_rho_bool10!, save_positions=(false, false))

	cb_lam_bool6 = DiscreteCallback(condition_lam_bool6, affect_lam_bool6!, save_positions=(false, false))

	cb_xi_bool10 = DiscreteCallback(condition_xi_bool10, affect_xi_bool10!, save_positions=(false, false))

	cb_beta_bool7 = DiscreteCallback(condition_beta_bool7, affect_beta_bool7!, save_positions=(false, false))

	cb_delta_bool5 = DiscreteCallback(condition_delta_bool5, affect_delta_bool5!, save_positions=(false, false))

	cb_eta_bool3 = DiscreteCallback(condition_eta_bool3, affect_eta_bool3!, save_positions=(false, false))

	cb_epsilon_bool9 = DiscreteCallback(condition_epsilon_bool9, affect_epsilon_bool9!, save_positions=(false, false))

	cb_mu_bool1 = DiscreteCallback(condition_mu_bool1, affect_mu_bool1!, save_positions=(false, false))

	cb_sigma_bool3 = DiscreteCallback(condition_sigma_bool3, affect_sigma_bool3!, save_positions=(false, false))

	cb_zeta_bool2 = DiscreteCallback(condition_zeta_bool2, affect_zeta_bool2!, save_positions=(false, false))

	cb_epsilon_bool3 = DiscreteCallback(condition_epsilon_bool3, affect_epsilon_bool3!, save_positions=(false, false))

	cb_kappa_bool10 = DiscreteCallback(condition_kappa_bool10, affect_kappa_bool10!, save_positions=(false, false))

	cb_gamma_bool1 = DiscreteCallback(condition_gamma_bool1, affect_gamma_bool1!, save_positions=(false, false))

	cb_gamma_bool11 = DiscreteCallback(condition_gamma_bool11, affect_gamma_bool11!, save_positions=(false, false))

	cb_delta_bool2 = DiscreteCallback(condition_delta_bool2, affect_delta_bool2!, save_positions=(false, false))

	cb_kappa_bool5 = DiscreteCallback(condition_kappa_bool5, affect_kappa_bool5!, save_positions=(false, false))

	cb_mu_bool6 = DiscreteCallback(condition_mu_bool6, affect_mu_bool6!, save_positions=(false, false))

	cb_zeta_bool6 = DiscreteCallback(condition_zeta_bool6, affect_zeta_bool6!, save_positions=(false, false))

	cb_nu_bool6 = DiscreteCallback(condition_nu_bool6, affect_nu_bool6!, save_positions=(false, false))

	cb_kappa_bool3 = DiscreteCallback(condition_kappa_bool3, affect_kappa_bool3!, save_positions=(false, false))

	cb_lam_bool5 = DiscreteCallback(condition_lam_bool5, affect_lam_bool5!, save_positions=(false, false))

	cb_zeta_bool10 = DiscreteCallback(condition_zeta_bool10, affect_zeta_bool10!, save_positions=(false, false))

	cb_gamma_bool3 = DiscreteCallback(condition_gamma_bool3, affect_gamma_bool3!, save_positions=(false, false))

	cb_gamma_bool14 = DiscreteCallback(condition_gamma_bool14, affect_gamma_bool14!, save_positions=(false, false))

	cb_lam_bool1 = DiscreteCallback(condition_lam_bool1, affect_lam_bool1!, save_positions=(false, false))

	cb_kappa_bool6 = DiscreteCallback(condition_kappa_bool6, affect_kappa_bool6!, save_positions=(false, false))

	cb_alpha_bool11 = DiscreteCallback(condition_alpha_bool11, affect_alpha_bool11!, save_positions=(false, false))

	cb_gamma_bool8 = DiscreteCallback(condition_gamma_bool8, affect_gamma_bool8!, save_positions=(false, false))

	cb_eta_bool1 = DiscreteCallback(condition_eta_bool1, affect_eta_bool1!, save_positions=(false, false))

	cb_sigma_bool5 = DiscreteCallback(condition_sigma_bool5, affect_sigma_bool5!, save_positions=(false, false))

	cb_beta_bool8 = DiscreteCallback(condition_beta_bool8, affect_beta_bool8!, save_positions=(false, false))

	cb_rho_bool9 = DiscreteCallback(condition_rho_bool9, affect_rho_bool9!, save_positions=(false, false))

	cb_zeta_bool9 = DiscreteCallback(condition_zeta_bool9, affect_zeta_bool9!, save_positions=(false, false))

	cb_kappa_bool8 = DiscreteCallback(condition_kappa_bool8, affect_kappa_bool8!, save_positions=(false, false))

	cb_eta_bool4 = DiscreteCallback(condition_eta_bool4, affect_eta_bool4!, save_positions=(false, false))

	cb_mu_bool3 = DiscreteCallback(condition_mu_bool3, affect_mu_bool3!, save_positions=(false, false))

	cb_delta_bool7 = DiscreteCallback(condition_delta_bool7, affect_delta_bool7!, save_positions=(false, false))

	cb_xi_bool3 = DiscreteCallback(condition_xi_bool3, affect_xi_bool3!, save_positions=(false, false))

	cb_epsilon_bool4 = DiscreteCallback(condition_epsilon_bool4, affect_epsilon_bool4!, save_positions=(false, false))

	cb_alpha_bool14 = DiscreteCallback(condition_alpha_bool14, affect_alpha_bool14!, save_positions=(false, false))

	cb_nu_bool5 = DiscreteCallback(condition_nu_bool5, affect_nu_bool5!, save_positions=(false, false))

	cb_epsilon_bool8 = DiscreteCallback(condition_epsilon_bool8, affect_epsilon_bool8!, save_positions=(false, false))

	cb_lam_bool2 = DiscreteCallback(condition_lam_bool2, affect_lam_bool2!, save_positions=(false, false))

	cb_alpha_bool8 = DiscreteCallback(condition_alpha_bool8, affect_alpha_bool8!, save_positions=(false, false))

	cb_zeta_bool4 = DiscreteCallback(condition_zeta_bool4, affect_zeta_bool4!, save_positions=(false, false))

	cb_eta_bool9 = DiscreteCallback(condition_eta_bool9, affect_eta_bool9!, save_positions=(false, false))

	cb_beta_bool9 = DiscreteCallback(condition_beta_bool9, affect_beta_bool9!, save_positions=(false, false))

	cb_epsilon_bool5 = DiscreteCallback(condition_epsilon_bool5, affect_epsilon_bool5!, save_positions=(false, false))

	cb_alpha_bool10 = DiscreteCallback(condition_alpha_bool10, affect_alpha_bool10!, save_positions=(false, false))

	cb_epsilon_bool7 = DiscreteCallback(condition_epsilon_bool7, affect_epsilon_bool7!, save_positions=(false, false))

	cb_gamma_bool7 = DiscreteCallback(condition_gamma_bool7, affect_gamma_bool7!, save_positions=(false, false))

	cb_xi_bool8 = DiscreteCallback(condition_xi_bool8, affect_xi_bool8!, save_positions=(false, false))

	cb_gamma_bool10 = DiscreteCallback(condition_gamma_bool10, affect_gamma_bool10!, save_positions=(false, false))

	cb_gamma_bool13 = DiscreteCallback(condition_gamma_bool13, affect_gamma_bool13!, save_positions=(false, false))

	cb_sigma_bool7 = DiscreteCallback(condition_sigma_bool7, affect_sigma_bool7!, save_positions=(false, false))

	cb_gamma_bool2 = DiscreteCallback(condition_gamma_bool2, affect_gamma_bool2!, save_positions=(false, false))

	cb_alpha_bool1 = DiscreteCallback(condition_alpha_bool1, affect_alpha_bool1!, save_positions=(false, false))

	cb_kappa_bool9 = DiscreteCallback(condition_kappa_bool9, affect_kappa_bool9!, save_positions=(false, false))

	cb_mu_bool4 = DiscreteCallback(condition_mu_bool4, affect_mu_bool4!, save_positions=(false, false))

	cb_sigma_bool8 = DiscreteCallback(condition_sigma_bool8, affect_sigma_bool8!, save_positions=(false, false))

	cb_nu_bool3 = DiscreteCallback(condition_nu_bool3, affect_nu_bool3!, save_positions=(false, false))

	cb_nu_bool1 = DiscreteCallback(condition_nu_bool1, affect_nu_bool1!, save_positions=(false, false))

	cb_kappa_bool1 = DiscreteCallback(condition_kappa_bool1, affect_kappa_bool1!, save_positions=(false, false))

	cb_rho_bool8 = DiscreteCallback(condition_rho_bool8, affect_rho_bool8!, save_positions=(false, false))

	cb_epsilon_bool10 = DiscreteCallback(condition_epsilon_bool10, affect_epsilon_bool10!, save_positions=(false, false))

	cb_gamma_bool6 = DiscreteCallback(condition_gamma_bool6, affect_gamma_bool6!, save_positions=(false, false))

	cb_alpha_bool9 = DiscreteCallback(condition_alpha_bool9, affect_alpha_bool9!, save_positions=(false, false))

	cb_epsilon_bool6 = DiscreteCallback(condition_epsilon_bool6, affect_epsilon_bool6!, save_positions=(false, false))

	cb_sigma_bool1 = DiscreteCallback(condition_sigma_bool1, affect_sigma_bool1!, save_positions=(false, false))

	cb_beta_bool10 = DiscreteCallback(condition_beta_bool10, affect_beta_bool10!, save_positions=(false, false))

	cb_xi_bool2 = DiscreteCallback(condition_xi_bool2, affect_xi_bool2!, save_positions=(false, false))

	cb_rho_bool5 = DiscreteCallback(condition_rho_bool5, affect_rho_bool5!, save_positions=(false, false))

	cb_alpha_bool7 = DiscreteCallback(condition_alpha_bool7, affect_alpha_bool7!, save_positions=(false, false))

	cb_delta_bool8 = DiscreteCallback(condition_delta_bool8, affect_delta_bool8!, save_positions=(false, false))

	cb_kappa_bool2 = DiscreteCallback(condition_kappa_bool2, affect_kappa_bool2!, save_positions=(false, false))

	cb_nu_bool2 = DiscreteCallback(condition_nu_bool2, affect_nu_bool2!, save_positions=(false, false))

	cb_alpha_bool3 = DiscreteCallback(condition_alpha_bool3, affect_alpha_bool3!, save_positions=(false, false))

	cb_delta_bool4 = DiscreteCallback(condition_delta_bool4, affect_delta_bool4!, save_positions=(false, false))

	cb_zeta_bool1 = DiscreteCallback(condition_zeta_bool1, affect_zeta_bool1!, save_positions=(false, false))

	cb_eta_bool10 = DiscreteCallback(condition_eta_bool10, affect_eta_bool10!, save_positions=(false, false))

	cb_beta_bool6 = DiscreteCallback(condition_beta_bool6, affect_beta_bool6!, save_positions=(false, false))

	cb_beta_bool1 = DiscreteCallback(condition_beta_bool1, affect_beta_bool1!, save_positions=(false, false))

	cb_rho_bool4 = DiscreteCallback(condition_rho_bool4, affect_rho_bool4!, save_positions=(false, false))

	cb_xi_bool6 = DiscreteCallback(condition_xi_bool6, affect_xi_bool6!, save_positions=(false, false))

	cb_sigma_bool10 = DiscreteCallback(condition_sigma_bool10, affect_sigma_bool10!, save_positions=(false, false))

	cb_sigma_bool6 = DiscreteCallback(condition_sigma_bool6, affect_sigma_bool6!, save_positions=(false, false))

	cb_alpha_bool2 = DiscreteCallback(condition_alpha_bool2, affect_alpha_bool2!, save_positions=(false, false))

	cb_zeta_bool3 = DiscreteCallback(condition_zeta_bool3, affect_zeta_bool3!, save_positions=(false, false))

	cb_epsilon_bool2 = DiscreteCallback(condition_epsilon_bool2, affect_epsilon_bool2!, save_positions=(false, false))

	cb_beta_bool5 = DiscreteCallback(condition_beta_bool5, affect_beta_bool5!, save_positions=(false, false))

	cb_gamma_bool9 = DiscreteCallback(condition_gamma_bool9, affect_gamma_bool9!, save_positions=(false, false))

	cb_gamma_bool12 = DiscreteCallback(condition_gamma_bool12, affect_gamma_bool12!, save_positions=(false, false))

	cb_mu_bool5 = DiscreteCallback(condition_mu_bool5, affect_mu_bool5!, save_positions=(false, false))

	cb_lam_bool3 = DiscreteCallback(condition_lam_bool3, affect_lam_bool3!, save_positions=(false, false))

	cb_sigma_bool4 = DiscreteCallback(condition_sigma_bool4, affect_sigma_bool4!, save_positions=(false, false))

	cb_xi_bool1 = DiscreteCallback(condition_xi_bool1, affect_xi_bool1!, save_positions=(false, false))

	cb_alpha_bool5 = DiscreteCallback(condition_alpha_bool5, affect_alpha_bool5!, save_positions=(false, false))

	cb_delta_bool6 = DiscreteCallback(condition_delta_bool6, affect_delta_bool6!, save_positions=(false, false))

	cb_sigma_bool9 = DiscreteCallback(condition_sigma_bool9, affect_sigma_bool9!, save_positions=(false, false))

	cb_alpha_bool13 = DiscreteCallback(condition_alpha_bool13, affect_alpha_bool13!, save_positions=(false, false))

	return CallbackSet(cb_delta_bool10, cb_beta_bool3, cb_alpha_bool12, cb_alpha_bool4, cb_epsilon_bool1, cb_eta_bool5, cb_eta_bool8, cb_kappa_bool4, cb_rho_bool6, cb_delta_bool9, cb_xi_bool7, cb_rho_bool2, cb_rho_bool3, cb_kappa_bool7, cb_zeta_bool8, cb_mu_bool2, cb_rho_bool1, cb_nu_bool4, cb_lam_bool4, cb_delta_bool3, cb_xi_bool5, cb_alpha_bool6, cb_zeta_bool7, cb_xi_bool9, cb_sigma_bool2, cb_beta_bool2, cb_beta_bool4, cb_delta_bool1, cb_xi_bool4, cb_gamma_bool5, cb_eta_bool6, cb_eta_bool7, cb_rho_bool7, cb_zeta_bool5, cb_gamma_bool4, cb_eta_bool2, cb_rho_bool10, cb_lam_bool6, cb_xi_bool10, cb_beta_bool7, cb_delta_bool5, cb_eta_bool3, cb_epsilon_bool9, cb_mu_bool1, cb_sigma_bool3, cb_zeta_bool2, cb_epsilon_bool3, cb_kappa_bool10, cb_gamma_bool1, cb_gamma_bool11, cb_delta_bool2, cb_kappa_bool5, cb_mu_bool6, cb_zeta_bool6, cb_nu_bool6, cb_kappa_bool3, cb_lam_bool5, cb_zeta_bool10, cb_gamma_bool3, cb_gamma_bool14, cb_lam_bool1, cb_kappa_bool6, cb_alpha_bool11, cb_gamma_bool8, cb_eta_bool1, cb_sigma_bool5, cb_beta_bool8, cb_rho_bool9, cb_zeta_bool9, cb_kappa_bool8, cb_eta_bool4, cb_mu_bool3, cb_delta_bool7, cb_xi_bool3, cb_epsilon_bool4, cb_alpha_bool14, cb_nu_bool5, cb_epsilon_bool8, cb_lam_bool2, cb_alpha_bool8, cb_zeta_bool4, cb_eta_bool9, cb_beta_bool9, cb_epsilon_bool5, cb_alpha_bool10, cb_epsilon_bool7, cb_gamma_bool7, cb_xi_bool8, cb_gamma_bool10, cb_gamma_bool13, cb_sigma_bool7, cb_gamma_bool2, cb_alpha_bool1, cb_kappa_bool9, cb_mu_bool4, cb_sigma_bool8, cb_nu_bool3, cb_nu_bool1, cb_kappa_bool1, cb_rho_bool8, cb_epsilon_bool10, cb_gamma_bool6, cb_alpha_bool9, cb_epsilon_bool6, cb_sigma_bool1, cb_beta_bool10, cb_xi_bool2, cb_rho_bool5, cb_alpha_bool7, cb_delta_bool8, cb_kappa_bool2, cb_nu_bool2, cb_alpha_bool3, cb_delta_bool4, cb_zeta_bool1, cb_eta_bool10, cb_beta_bool6, cb_beta_bool1, cb_rho_bool4, cb_xi_bool6, cb_sigma_bool10, cb_sigma_bool6, cb_alpha_bool2, cb_zeta_bool3, cb_epsilon_bool2, cb_beta_bool5, cb_gamma_bool9, cb_gamma_bool12, cb_mu_bool5, cb_lam_bool3, cb_sigma_bool4, cb_xi_bool1, cb_alpha_bool5, cb_delta_bool6, cb_sigma_bool9, cb_alpha_bool13), [activeAtTime0_delta_bool10!, activeAtTime0_beta_bool3!, activeAtTime0_alpha_bool12!, activeAtTime0_alpha_bool4!, activeAtTime0_epsilon_bool1!, activeAtTime0_eta_bool5!, activeAtTime0_eta_bool8!, activeAtTime0_kappa_bool4!, activeAtTime0_rho_bool6!, activeAtTime0_delta_bool9!, activeAtTime0_xi_bool7!, activeAtTime0_rho_bool2!, activeAtTime0_rho_bool3!, activeAtTime0_kappa_bool7!, activeAtTime0_zeta_bool8!, activeAtTime0_mu_bool2!, activeAtTime0_rho_bool1!, activeAtTime0_nu_bool4!, activeAtTime0_lam_bool4!, activeAtTime0_delta_bool3!, activeAtTime0_xi_bool5!, activeAtTime0_alpha_bool6!, activeAtTime0_zeta_bool7!, activeAtTime0_xi_bool9!, activeAtTime0_sigma_bool2!, activeAtTime0_beta_bool2!, activeAtTime0_beta_bool4!, activeAtTime0_delta_bool1!, activeAtTime0_xi_bool4!, activeAtTime0_gamma_bool5!, activeAtTime0_eta_bool6!, activeAtTime0_eta_bool7!, activeAtTime0_rho_bool7!, activeAtTime0_zeta_bool5!, activeAtTime0_gamma_bool4!, activeAtTime0_eta_bool2!, activeAtTime0_rho_bool10!, activeAtTime0_lam_bool6!, activeAtTime0_xi_bool10!, activeAtTime0_beta_bool7!, activeAtTime0_delta_bool5!, activeAtTime0_eta_bool3!, activeAtTime0_epsilon_bool9!, activeAtTime0_mu_bool1!, activeAtTime0_sigma_bool3!, activeAtTime0_zeta_bool2!, activeAtTime0_epsilon_bool3!, activeAtTime0_kappa_bool10!, activeAtTime0_gamma_bool1!, activeAtTime0_gamma_bool11!, activeAtTime0_delta_bool2!, activeAtTime0_kappa_bool5!, activeAtTime0_mu_bool6!, activeAtTime0_zeta_bool6!, activeAtTime0_nu_bool6!, activeAtTime0_kappa_bool3!, activeAtTime0_lam_bool5!, activeAtTime0_zeta_bool10!, activeAtTime0_gamma_bool3!, activeAtTime0_gamma_bool14!, activeAtTime0_lam_bool1!, activeAtTime0_kappa_bool6!, activeAtTime0_alpha_bool11!, activeAtTime0_gamma_bool8!, activeAtTime0_eta_bool1!, activeAtTime0_sigma_bool5!, activeAtTime0_beta_bool8!, activeAtTime0_rho_bool9!, activeAtTime0_zeta_bool9!, activeAtTime0_kappa_bool8!, activeAtTime0_eta_bool4!, activeAtTime0_mu_bool3!, activeAtTime0_delta_bool7!, activeAtTime0_xi_bool3!, activeAtTime0_epsilon_bool4!, activeAtTime0_alpha_bool14!, activeAtTime0_nu_bool5!, activeAtTime0_epsilon_bool8!, activeAtTime0_lam_bool2!, activeAtTime0_alpha_bool8!, activeAtTime0_zeta_bool4!, activeAtTime0_eta_bool9!, activeAtTime0_beta_bool9!, activeAtTime0_epsilon_bool5!, activeAtTime0_alpha_bool10!, activeAtTime0_epsilon_bool7!, activeAtTime0_gamma_bool7!, activeAtTime0_xi_bool8!, activeAtTime0_gamma_bool10!, activeAtTime0_gamma_bool13!, activeAtTime0_sigma_bool7!, activeAtTime0_gamma_bool2!, activeAtTime0_alpha_bool1!, activeAtTime0_kappa_bool9!, activeAtTime0_mu_bool4!, activeAtTime0_sigma_bool8!, activeAtTime0_nu_bool3!, activeAtTime0_nu_bool1!, activeAtTime0_kappa_bool1!, activeAtTime0_rho_bool8!, activeAtTime0_epsilon_bool10!, activeAtTime0_gamma_bool6!, activeAtTime0_alpha_bool9!, activeAtTime0_epsilon_bool6!, activeAtTime0_sigma_bool1!, activeAtTime0_beta_bool10!, activeAtTime0_xi_bool2!, activeAtTime0_rho_bool5!, activeAtTime0_alpha_bool7!, activeAtTime0_delta_bool8!, activeAtTime0_kappa_bool2!, activeAtTime0_nu_bool2!, activeAtTime0_alpha_bool3!, activeAtTime0_delta_bool4!, activeAtTime0_zeta_bool1!, activeAtTime0_eta_bool10!, activeAtTime0_beta_bool6!, activeAtTime0_beta_bool1!, activeAtTime0_rho_bool4!, activeAtTime0_xi_bool6!, activeAtTime0_sigma_bool10!, activeAtTime0_sigma_bool6!, activeAtTime0_alpha_bool2!, activeAtTime0_zeta_bool3!, activeAtTime0_epsilon_bool2!, activeAtTime0_beta_bool5!, activeAtTime0_gamma_bool9!, activeAtTime0_gamma_bool12!, activeAtTime0_mu_bool5!, activeAtTime0_lam_bool3!, activeAtTime0_sigma_bool4!, activeAtTime0_xi_bool1!, activeAtTime0_alpha_bool5!, activeAtTime0_delta_bool6!, activeAtTime0_sigma_bool9!, activeAtTime0_alpha_bool13!]
end


function condition_delta_bool10(u, t, integrator)
	t == 50 + integrator.p[160]
end
function affect_delta_bool10!(integrator)
	integrator.p[96] = 1.0
end
function activeAtTime0_delta_bool10!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[96] = 0.0 # Default to being off
	if (t > 50 + p[160])
		p[96] = 1.0
	end
end


function condition_beta_bool3(u, t, integrator)
	t == integrator.p[160] + 22
end
function affect_beta_bool3!(integrator)
	integrator.p[1] = 1.0
end
function activeAtTime0_beta_bool3!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[1] = 0.0 # Default to being off
	if !(t ≤ p[160] + 22)
		p[1] = 1.0
	end
end


function condition_alpha_bool12(u, t, integrator)
	t == 28 + integrator.p[160]
end
function affect_alpha_bool12!(integrator)
	integrator.p[2] = 1.0
end
function activeAtTime0_alpha_bool12!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[2] = 0.0 # Default to being off
	if (t > 28 + p[160])
		p[2] = 1.0
	end
end


function condition_alpha_bool4(u, t, integrator)
	t == 4 + integrator.p[160]
end
function affect_alpha_bool4!(integrator)
	integrator.p[97] = 1.0
end
function activeAtTime0_alpha_bool4!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[97] = 0.0 # Default to being off
	if (t > 4 + p[160])
		p[97] = 1.0
	end
end


function condition_epsilon_bool1(u, t, integrator)
	t == 12 + integrator.p[160]
end
function affect_epsilon_bool1!(integrator)
	integrator.p[143] = 1.0
end
function activeAtTime0_epsilon_bool1!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[143] = 0.0 # Default to being off
	if !(t ≤ 12 + p[160])
		p[143] = 1.0
	end
end


function condition_eta_bool5(u, t, integrator)
	t == integrator.p[160] + 38
end
function affect_eta_bool5!(integrator)
	integrator.p[144] = 1.0
end
function activeAtTime0_eta_bool5!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[144] = 0.0 # Default to being off
	if !(t ≤ p[160] + 38)
		p[144] = 1.0
	end
end


function condition_eta_bool8(u, t, integrator)
	t == 38 + integrator.p[160]
end
function affect_eta_bool8!(integrator)
	integrator.p[146] = 1.0
end
function activeAtTime0_eta_bool8!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[146] = 0.0 # Default to being off
	if (t > 38 + p[160])
		p[146] = 1.0
	end
end


function condition_kappa_bool4(u, t, integrator)
	t == 22 + integrator.p[160]
end
function affect_kappa_bool4!(integrator)
	integrator.p[147] = 1.0
end
function activeAtTime0_kappa_bool4!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[147] = 0.0 # Default to being off
	if (t > 22 + p[160])
		p[147] = 1.0
	end
end


function condition_rho_bool6(u, t, integrator)
	t == 38 + integrator.p[160]
end
function affect_rho_bool6!(integrator)
	integrator.p[148] = 1.0
end
function activeAtTime0_rho_bool6!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[148] = 0.0 # Default to being off
	if (t > 38 + p[160])
		p[148] = 1.0
	end
end


function condition_delta_bool9(u, t, integrator)
	t == integrator.p[160] + 50
end
function affect_delta_bool9!(integrator)
	integrator.p[150] = 1.0
end
function activeAtTime0_delta_bool9!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[150] = 0.0 # Default to being off
	if !(t ≤ p[160] + 50)
		p[150] = 1.0
	end
end


function condition_xi_bool7(u, t, integrator)
	t == integrator.p[160] + 50
end
function affect_xi_bool7!(integrator)
	integrator.p[151] = 1.0
end
function activeAtTime0_xi_bool7!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[151] = 0.0 # Default to being off
	if !(t ≤ p[160] + 50)
		p[151] = 1.0
	end
end


function condition_rho_bool2(u, t, integrator)
	t == 22 + integrator.p[160]
end
function affect_rho_bool2!(integrator)
	integrator.p[3] = 1.0
end
function activeAtTime0_rho_bool2!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[3] = 0.0 # Default to being off
	if (t > 22 + p[160])
		p[3] = 1.0
	end
end


function condition_rho_bool3(u, t, integrator)
	t == integrator.p[160] + 38
end
function affect_rho_bool3!(integrator)
	integrator.p[4] = 1.0
end
function activeAtTime0_rho_bool3!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[4] = 0.0 # Default to being off
	if !(t ≤ p[160] + 38)
		p[4] = 1.0
	end
end


function condition_kappa_bool7(u, t, integrator)
	t == integrator.p[160] + 50
end
function affect_kappa_bool7!(integrator)
	integrator.p[5] = 1.0
end
function activeAtTime0_kappa_bool7!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[5] = 0.0 # Default to being off
	if !(t ≤ p[160] + 50)
		p[5] = 1.0
	end
end


function condition_zeta_bool8(u, t, integrator)
	t == 38 + integrator.p[160]
end
function affect_zeta_bool8!(integrator)
	integrator.p[61] = 1.0
end
function activeAtTime0_zeta_bool8!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[61] = 0.0 # Default to being off
	if (t > 38 + p[160])
		p[61] = 1.0
	end
end


function condition_mu_bool2(u, t, integrator)
	t == 22 + integrator.p[160]
end
function affect_mu_bool2!(integrator)
	integrator.p[100] = 1.0
end
function activeAtTime0_mu_bool2!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[100] = 0.0 # Default to being off
	if (t > 22 + p[160])
		p[100] = 1.0
	end
end


function condition_rho_bool1(u, t, integrator)
	t == 22 + integrator.p[160]
end
function affect_rho_bool1!(integrator)
	integrator.p[99] = 1.0
end
function activeAtTime0_rho_bool1!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[99] = 0.0 # Default to being off
	if !(t ≤ 22 + p[160])
		p[99] = 1.0
	end
end


function condition_nu_bool4(u, t, integrator)
	t == 22 + integrator.p[160]
end
function affect_nu_bool4!(integrator)
	integrator.p[7] = 1.0
end
function activeAtTime0_nu_bool4!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[7] = 0.0 # Default to being off
	if (t > 22 + p[160])
		p[7] = 1.0
	end
end


function condition_lam_bool4(u, t, integrator)
	t == 22 + integrator.p[160]
end
function affect_lam_bool4!(integrator)
	integrator.p[62] = 1.0
end
function activeAtTime0_lam_bool4!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[62] = 0.0 # Default to being off
	if (t > 22 + p[160])
		p[62] = 1.0
	end
end


function condition_delta_bool3(u, t, integrator)
	t == integrator.p[160] + 22
end
function affect_delta_bool3!(integrator)
	integrator.p[101] = 1.0
end
function activeAtTime0_delta_bool3!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[101] = 0.0 # Default to being off
	if !(t ≤ p[160] + 22)
		p[101] = 1.0
	end
end


function condition_xi_bool5(u, t, integrator)
	t == integrator.p[160] + 38
end
function affect_xi_bool5!(integrator)
	integrator.p[103] = 1.0
end
function activeAtTime0_xi_bool5!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[103] = 0.0 # Default to being off
	if !(t ≤ p[160] + 38)
		p[103] = 1.0
	end
end


function condition_alpha_bool6(u, t, integrator)
	t == 22 + integrator.p[160]
end
function affect_alpha_bool6!(integrator)
	integrator.p[9] = 1.0
end
function activeAtTime0_alpha_bool6!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[9] = 0.0 # Default to being off
	if (t > 22 + p[160])
		p[9] = 1.0
	end
end


function condition_zeta_bool7(u, t, integrator)
	t == integrator.p[160] + 50
end
function affect_zeta_bool7!(integrator)
	integrator.p[10] = 1.0
end
function activeAtTime0_zeta_bool7!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[10] = 0.0 # Default to being off
	if !(t ≤ p[160] + 50)
		p[10] = 1.0
	end
end


function condition_xi_bool9(u, t, integrator)
	t == integrator.p[160] + 50
end
function affect_xi_bool9!(integrator)
	integrator.p[154] = 1.0
end
function activeAtTime0_xi_bool9!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[154] = 0.0 # Default to being off
	if !(t ≤ p[160] + 50)
		p[154] = 1.0
	end
end


function condition_sigma_bool2(u, t, integrator)
	t == 22 + integrator.p[160]
end
function affect_sigma_bool2!(integrator)
	integrator.p[104] = 1.0
end
function activeAtTime0_sigma_bool2!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[104] = 0.0 # Default to being off
	if (t > 22 + p[160])
		p[104] = 1.0
	end
end


function condition_beta_bool2(u, t, integrator)
	t == 4 + integrator.p[160]
end
function affect_beta_bool2!(integrator)
	integrator.p[105] = 1.0
end
function activeAtTime0_beta_bool2!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[105] = 0.0 # Default to being off
	if (t > 4 + p[160])
		p[105] = 1.0
	end
end


function condition_beta_bool4(u, t, integrator)
	t == 4 + integrator.p[160]
end
function affect_beta_bool4!(integrator)
	integrator.p[107] = 1.0
end
function activeAtTime0_beta_bool4!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[107] = 0.0 # Default to being off
	if (t > 4 + p[160])
		p[107] = 1.0
	end
end


function condition_delta_bool1(u, t, integrator)
	t == 4 + integrator.p[160]
end
function affect_delta_bool1!(integrator)
	integrator.p[156] = 1.0
end
function activeAtTime0_delta_bool1!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[156] = 0.0 # Default to being off
	if !(t ≤ 4 + p[160])
		p[156] = 1.0
	end
end


function condition_xi_bool4(u, t, integrator)
	t == 22 + integrator.p[160]
end
function affect_xi_bool4!(integrator)
	integrator.p[157] = 1.0
end
function activeAtTime0_xi_bool4!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[157] = 0.0 # Default to being off
	if (t > 22 + p[160])
		p[157] = 1.0
	end
end


function condition_gamma_bool5(u, t, integrator)
	t == integrator.p[160] + 22
end
function affect_gamma_bool5!(integrator)
	integrator.p[158] = 1.0
end
function activeAtTime0_gamma_bool5!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[158] = 0.0 # Default to being off
	if !(t ≤ p[160] + 22)
		p[158] = 1.0
	end
end


function condition_eta_bool6(u, t, integrator)
	t == 38 + integrator.p[160]
end
function affect_eta_bool6!(integrator)
	integrator.p[66] = 1.0
end
function activeAtTime0_eta_bool6!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[66] = 0.0 # Default to being off
	if (t > 38 + p[160])
		p[66] = 1.0
	end
end


function condition_eta_bool7(u, t, integrator)
	t == integrator.p[160] + 50
end
function affect_eta_bool7!(integrator)
	integrator.p[111] = 1.0
end
function activeAtTime0_eta_bool7!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[111] = 0.0 # Default to being off
	if !(t ≤ p[160] + 50)
		p[111] = 1.0
	end
end


function condition_rho_bool7(u, t, integrator)
	t == integrator.p[160] + 50
end
function affect_rho_bool7!(integrator)
	integrator.p[11] = 1.0
end
function activeAtTime0_rho_bool7!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[11] = 0.0 # Default to being off
	if !(t ≤ p[160] + 50)
		p[11] = 1.0
	end
end


function condition_zeta_bool5(u, t, integrator)
	t == integrator.p[160] + 38
end
function affect_zeta_bool5!(integrator)
	integrator.p[12] = 1.0
end
function activeAtTime0_zeta_bool5!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[12] = 0.0 # Default to being off
	if !(t ≤ p[160] + 38)
		p[12] = 1.0
	end
end


function condition_gamma_bool4(u, t, integrator)
	t == 4 + integrator.p[160]
end
function affect_gamma_bool4!(integrator)
	integrator.p[67] = 1.0
end
function activeAtTime0_gamma_bool4!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[67] = 0.0 # Default to being off
	if (t > 4 + p[160])
		p[67] = 1.0
	end
end


function condition_eta_bool2(u, t, integrator)
	t == 22 + integrator.p[160]
end
function affect_eta_bool2!(integrator)
	integrator.p[13] = 1.0
end
function activeAtTime0_eta_bool2!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[13] = 0.0 # Default to being off
	if (t > 22 + p[160])
		p[13] = 1.0
	end
end


function condition_rho_bool10(u, t, integrator)
	t == 50 + integrator.p[160]
end
function affect_rho_bool10!(integrator)
	integrator.p[14] = 1.0
end
function activeAtTime0_rho_bool10!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[14] = 0.0 # Default to being off
	if (t > 50 + p[160])
		p[14] = 1.0
	end
end


function condition_lam_bool6(u, t, integrator)
	t == 50 + integrator.p[160]
end
function affect_lam_bool6!(integrator)
	integrator.p[15] = 1.0
end
function activeAtTime0_lam_bool6!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[15] = 0.0 # Default to being off
	if (t > 50 + p[160])
		p[15] = 1.0
	end
end


function condition_xi_bool10(u, t, integrator)
	t == 50 + integrator.p[160]
end
function affect_xi_bool10!(integrator)
	integrator.p[16] = 1.0
end
function activeAtTime0_xi_bool10!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[16] = 0.0 # Default to being off
	if (t > 50 + p[160])
		p[16] = 1.0
	end
end


function condition_beta_bool7(u, t, integrator)
	t == integrator.p[160] + 50
end
function affect_beta_bool7!(integrator)
	integrator.p[112] = 1.0
end
function activeAtTime0_beta_bool7!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[112] = 0.0 # Default to being off
	if !(t ≤ p[160] + 50)
		p[112] = 1.0
	end
end


function condition_delta_bool5(u, t, integrator)
	t == integrator.p[160] + 22
end
function affect_delta_bool5!(integrator)
	integrator.p[70] = 1.0
end
function activeAtTime0_delta_bool5!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[70] = 0.0 # Default to being off
	if !(t ≤ p[160] + 22)
		p[70] = 1.0
	end
end


function condition_eta_bool3(u, t, integrator)
	t == integrator.p[160] + 38
end
function affect_eta_bool3!(integrator)
	integrator.p[161] = 1.0
end
function activeAtTime0_eta_bool3!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[161] = 0.0 # Default to being off
	if !(t ≤ p[160] + 38)
		p[161] = 1.0
	end
end


function condition_epsilon_bool9(u, t, integrator)
	t == integrator.p[160] + 50
end
function affect_epsilon_bool9!(integrator)
	integrator.p[69] = 1.0
end
function activeAtTime0_epsilon_bool9!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[69] = 0.0 # Default to being off
	if !(t ≤ p[160] + 50)
		p[69] = 1.0
	end
end


function condition_mu_bool1(u, t, integrator)
	t == 22 + integrator.p[160]
end
function affect_mu_bool1!(integrator)
	integrator.p[113] = 1.0
end
function activeAtTime0_mu_bool1!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[113] = 0.0 # Default to being off
	if !(t ≤ 22 + p[160])
		p[113] = 1.0
	end
end


function condition_sigma_bool3(u, t, integrator)
	t == integrator.p[160] + 38
end
function affect_sigma_bool3!(integrator)
	integrator.p[114] = 1.0
end
function activeAtTime0_sigma_bool3!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[114] = 0.0 # Default to being off
	if !(t ≤ p[160] + 38)
		p[114] = 1.0
	end
end


function condition_zeta_bool2(u, t, integrator)
	t == 22 + integrator.p[160]
end
function affect_zeta_bool2!(integrator)
	integrator.p[162] = 1.0
end
function activeAtTime0_zeta_bool2!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[162] = 0.0 # Default to being off
	if (t > 22 + p[160])
		p[162] = 1.0
	end
end


function condition_epsilon_bool3(u, t, integrator)
	t == integrator.p[160] + 38
end
function affect_epsilon_bool3!(integrator)
	integrator.p[115] = 1.0
end
function activeAtTime0_epsilon_bool3!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[115] = 0.0 # Default to being off
	if !(t ≤ p[160] + 38)
		p[115] = 1.0
	end
end


function condition_kappa_bool10(u, t, integrator)
	t == 50 + integrator.p[160]
end
function affect_kappa_bool10!(integrator)
	integrator.p[163] = 1.0
end
function activeAtTime0_kappa_bool10!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[163] = 0.0 # Default to being off
	if (t > 50 + p[160])
		p[163] = 1.0
	end
end


function condition_gamma_bool1(u, t, integrator)
	t == 4 + integrator.p[160]
end
function affect_gamma_bool1!(integrator)
	integrator.p[71] = 1.0
end
function activeAtTime0_gamma_bool1!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[71] = 0.0 # Default to being off
	if !(t ≤ 4 + p[160])
		p[71] = 1.0
	end
end


function condition_gamma_bool11(u, t, integrator)
	t == integrator.p[160] + 50
end
function affect_gamma_bool11!(integrator)
	integrator.p[68] = 1.0
end
function activeAtTime0_gamma_bool11!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[68] = 0.0 # Default to being off
	if !(t ≤ p[160] + 50)
		p[68] = 1.0
	end
end


function condition_delta_bool2(u, t, integrator)
	t == 4 + integrator.p[160]
end
function affect_delta_bool2!(integrator)
	integrator.p[18] = 1.0
end
function activeAtTime0_delta_bool2!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[18] = 0.0 # Default to being off
	if (t > 4 + p[160])
		p[18] = 1.0
	end
end


function condition_kappa_bool5(u, t, integrator)
	t == integrator.p[160] + 38
end
function affect_kappa_bool5!(integrator)
	integrator.p[72] = 1.0
end
function activeAtTime0_kappa_bool5!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[72] = 0.0 # Default to being off
	if !(t ≤ p[160] + 38)
		p[72] = 1.0
	end
end


function condition_mu_bool6(u, t, integrator)
	t == 50 + integrator.p[160]
end
function affect_mu_bool6!(integrator)
	integrator.p[165] = 1.0
end
function activeAtTime0_mu_bool6!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[165] = 0.0 # Default to being off
	if (t > 50 + p[160])
		p[165] = 1.0
	end
end


function condition_zeta_bool6(u, t, integrator)
	t == 38 + integrator.p[160]
end
function affect_zeta_bool6!(integrator)
	integrator.p[20] = 1.0
end
function activeAtTime0_zeta_bool6!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[20] = 0.0 # Default to being off
	if (t > 38 + p[160])
		p[20] = 1.0
	end
end


function condition_nu_bool6(u, t, integrator)
	t == 50 + integrator.p[160]
end
function affect_nu_bool6!(integrator)
	integrator.p[74] = 1.0
end
function activeAtTime0_nu_bool6!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[74] = 0.0 # Default to being off
	if (t > 50 + p[160])
		p[74] = 1.0
	end
end


function condition_kappa_bool3(u, t, integrator)
	t == integrator.p[160] + 38
end
function affect_kappa_bool3!(integrator)
	integrator.p[21] = 1.0
end
function activeAtTime0_kappa_bool3!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[21] = 0.0 # Default to being off
	if !(t ≤ p[160] + 38)
		p[21] = 1.0
	end
end


function condition_lam_bool5(u, t, integrator)
	t == integrator.p[160] + 50
end
function affect_lam_bool5!(integrator)
	integrator.p[75] = 1.0
end
function activeAtTime0_lam_bool5!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[75] = 0.0 # Default to being off
	if !(t ≤ p[160] + 50)
		p[75] = 1.0
	end
end


function condition_zeta_bool10(u, t, integrator)
	t == 50 + integrator.p[160]
end
function affect_zeta_bool10!(integrator)
	integrator.p[73] = 1.0
end
function activeAtTime0_zeta_bool10!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[73] = 0.0 # Default to being off
	if (t > 50 + p[160])
		p[73] = 1.0
	end
end


function condition_gamma_bool3(u, t, integrator)
	t == integrator.p[160] + 22
end
function affect_gamma_bool3!(integrator)
	integrator.p[167] = 1.0
end
function activeAtTime0_gamma_bool3!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[167] = 0.0 # Default to being off
	if !(t ≤ p[160] + 22)
		p[167] = 1.0
	end
end


function condition_gamma_bool14(u, t, integrator)
	t == 50 + integrator.p[160]
end
function affect_gamma_bool14!(integrator)
	integrator.p[166] = 1.0
end
function activeAtTime0_gamma_bool14!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[166] = 0.0 # Default to being off
	if (t > 50 + p[160])
		p[166] = 1.0
	end
end


function condition_lam_bool1(u, t, integrator)
	t == 22 + integrator.p[160]
end
function affect_lam_bool1!(integrator)
	integrator.p[117] = 1.0
end
function activeAtTime0_lam_bool1!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[117] = 0.0 # Default to being off
	if !(t ≤ 22 + p[160])
		p[117] = 1.0
	end
end


function condition_kappa_bool6(u, t, integrator)
	t == 38 + integrator.p[160]
end
function affect_kappa_bool6!(integrator)
	integrator.p[23] = 1.0
end
function activeAtTime0_kappa_bool6!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[23] = 0.0 # Default to being off
	if (t > 38 + p[160])
		p[23] = 1.0
	end
end


function condition_alpha_bool11(u, t, integrator)
	t == integrator.p[160] + 50
end
function affect_alpha_bool11!(integrator)
	integrator.p[118] = 1.0
end
function activeAtTime0_alpha_bool11!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[118] = 0.0 # Default to being off
	if !(t ≤ p[160] + 50)
		p[118] = 1.0
	end
end


function condition_gamma_bool8(u, t, integrator)
	t == 22 + integrator.p[160]
end
function affect_gamma_bool8!(integrator)
	integrator.p[22] = 1.0
end
function activeAtTime0_gamma_bool8!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[22] = 0.0 # Default to being off
	if (t > 22 + p[160])
		p[22] = 1.0
	end
end


function condition_eta_bool1(u, t, integrator)
	t == 22 + integrator.p[160]
end
function affect_eta_bool1!(integrator)
	integrator.p[76] = 1.0
end
function activeAtTime0_eta_bool1!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[76] = 0.0 # Default to being off
	if !(t ≤ 22 + p[160])
		p[76] = 1.0
	end
end


function condition_sigma_bool5(u, t, integrator)
	t == integrator.p[160] + 38
end
function affect_sigma_bool5!(integrator)
	integrator.p[120] = 1.0
end
function activeAtTime0_sigma_bool5!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[120] = 0.0 # Default to being off
	if !(t ≤ p[160] + 38)
		p[120] = 1.0
	end
end


function condition_beta_bool8(u, t, integrator)
	t == 22 + integrator.p[160]
end
function affect_beta_bool8!(integrator)
	integrator.p[24] = 1.0
end
function activeAtTime0_beta_bool8!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[24] = 0.0 # Default to being off
	if (t > 22 + p[160])
		p[24] = 1.0
	end
end


function condition_rho_bool9(u, t, integrator)
	t == integrator.p[160] + 50
end
function affect_rho_bool9!(integrator)
	integrator.p[122] = 1.0
end
function activeAtTime0_rho_bool9!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[122] = 0.0 # Default to being off
	if !(t ≤ p[160] + 50)
		p[122] = 1.0
	end
end


function condition_zeta_bool9(u, t, integrator)
	t == integrator.p[160] + 50
end
function affect_zeta_bool9!(integrator)
	integrator.p[25] = 1.0
end
function activeAtTime0_zeta_bool9!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[25] = 0.0 # Default to being off
	if !(t ≤ p[160] + 50)
		p[25] = 1.0
	end
end


function condition_kappa_bool8(u, t, integrator)
	t == 38 + integrator.p[160]
end
function affect_kappa_bool8!(integrator)
	integrator.p[26] = 1.0
end
function activeAtTime0_kappa_bool8!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[26] = 0.0 # Default to being off
	if (t > 38 + p[160])
		p[26] = 1.0
	end
end


function condition_eta_bool4(u, t, integrator)
	t == 22 + integrator.p[160]
end
function affect_eta_bool4!(integrator)
	integrator.p[170] = 1.0
end
function activeAtTime0_eta_bool4!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[170] = 0.0 # Default to being off
	if (t > 22 + p[160])
		p[170] = 1.0
	end
end


function condition_mu_bool3(u, t, integrator)
	t == integrator.p[160] + 50
end
function affect_mu_bool3!(integrator)
	integrator.p[171] = 1.0
end
function activeAtTime0_mu_bool3!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[171] = 0.0 # Default to being off
	if !(t ≤ p[160] + 50)
		p[171] = 1.0
	end
end


function condition_delta_bool7(u, t, integrator)
	t == integrator.p[160] + 50
end
function affect_delta_bool7!(integrator)
	integrator.p[27] = 1.0
end
function activeAtTime0_delta_bool7!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[27] = 0.0 # Default to being off
	if !(t ≤ p[160] + 50)
		p[27] = 1.0
	end
end


function condition_xi_bool3(u, t, integrator)
	t == integrator.p[160] + 38
end
function affect_xi_bool3!(integrator)
	integrator.p[124] = 1.0
end
function activeAtTime0_xi_bool3!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[124] = 0.0 # Default to being off
	if !(t ≤ p[160] + 38)
		p[124] = 1.0
	end
end


function condition_epsilon_bool4(u, t, integrator)
	t == 12 + integrator.p[160]
end
function affect_epsilon_bool4!(integrator)
	integrator.p[172] = 1.0
end
function activeAtTime0_epsilon_bool4!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[172] = 0.0 # Default to being off
	if (t > 12 + p[160])
		p[172] = 1.0
	end
end


function condition_alpha_bool14(u, t, integrator)
	t == 50 + integrator.p[160]
end
function affect_alpha_bool14!(integrator)
	integrator.p[80] = 1.0
end
function activeAtTime0_alpha_bool14!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[80] = 0.0 # Default to being off
	if (t > 50 + p[160])
		p[80] = 1.0
	end
end


function condition_nu_bool5(u, t, integrator)
	t == integrator.p[160] + 50
end
function affect_nu_bool5!(integrator)
	integrator.p[29] = 1.0
end
function activeAtTime0_nu_bool5!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[29] = 0.0 # Default to being off
	if !(t ≤ p[160] + 50)
		p[29] = 1.0
	end
end


function condition_epsilon_bool8(u, t, integrator)
	t == 38 + integrator.p[160]
end
function affect_epsilon_bool8!(integrator)
	integrator.p[28] = 1.0
end
function activeAtTime0_epsilon_bool8!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[28] = 0.0 # Default to being off
	if (t > 38 + p[160])
		p[28] = 1.0
	end
end


function condition_lam_bool2(u, t, integrator)
	t == 22 + integrator.p[160]
end
function affect_lam_bool2!(integrator)
	integrator.p[126] = 1.0
end
function activeAtTime0_lam_bool2!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[126] = 0.0 # Default to being off
	if (t > 22 + p[160])
		p[126] = 1.0
	end
end


function condition_alpha_bool8(u, t, integrator)
	t == 22 + integrator.p[160]
end
function affect_alpha_bool8!(integrator)
	integrator.p[31] = 1.0
end
function activeAtTime0_alpha_bool8!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[31] = 0.0 # Default to being off
	if (t > 22 + p[160])
		p[31] = 1.0
	end
end


function condition_zeta_bool4(u, t, integrator)
	t == 22 + integrator.p[160]
end
function affect_zeta_bool4!(integrator)
	integrator.p[32] = 1.0
end
function activeAtTime0_zeta_bool4!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[32] = 0.0 # Default to being off
	if (t > 22 + p[160])
		p[32] = 1.0
	end
end


function condition_eta_bool9(u, t, integrator)
	t == integrator.p[160] + 50
end
function affect_eta_bool9!(integrator)
	integrator.p[127] = 1.0
end
function activeAtTime0_eta_bool9!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[127] = 0.0 # Default to being off
	if !(t ≤ p[160] + 50)
		p[127] = 1.0
	end
end


function condition_beta_bool9(u, t, integrator)
	t == integrator.p[160] + 50
end
function affect_beta_bool9!(integrator)
	integrator.p[33] = 1.0
end
function activeAtTime0_beta_bool9!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[33] = 0.0 # Default to being off
	if !(t ≤ p[160] + 50)
		p[33] = 1.0
	end
end


function condition_epsilon_bool5(u, t, integrator)
	t == integrator.p[160] + 38
end
function affect_epsilon_bool5!(integrator)
	integrator.p[128] = 1.0
end
function activeAtTime0_epsilon_bool5!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[128] = 0.0 # Default to being off
	if !(t ≤ p[160] + 38)
		p[128] = 1.0
	end
end


function condition_alpha_bool10(u, t, integrator)
	t == 28 + integrator.p[160]
end
function affect_alpha_bool10!(integrator)
	integrator.p[175] = 1.0
end
function activeAtTime0_alpha_bool10!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[175] = 0.0 # Default to being off
	if (t > 28 + p[160])
		p[175] = 1.0
	end
end


function condition_epsilon_bool7(u, t, integrator)
	t == integrator.p[160] + 50
end
function affect_epsilon_bool7!(integrator)
	integrator.p[129] = 1.0
end
function activeAtTime0_epsilon_bool7!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[129] = 0.0 # Default to being off
	if !(t ≤ p[160] + 50)
		p[129] = 1.0
	end
end


function condition_gamma_bool7(u, t, integrator)
	t == integrator.p[160] + 28
end
function affect_gamma_bool7!(integrator)
	integrator.p[174] = 1.0
end
function activeAtTime0_gamma_bool7!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[174] = 0.0 # Default to being off
	if !(t ≤ p[160] + 28)
		p[174] = 1.0
	end
end


function condition_xi_bool8(u, t, integrator)
	t == 38 + integrator.p[160]
end
function affect_xi_bool8!(integrator)
	integrator.p[35] = 1.0
end
function activeAtTime0_xi_bool8!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[35] = 0.0 # Default to being off
	if (t > 38 + p[160])
		p[35] = 1.0
	end
end


function condition_gamma_bool10(u, t, integrator)
	t == 28 + integrator.p[160]
end
function affect_gamma_bool10!(integrator)
	integrator.p[82] = 1.0
end
function activeAtTime0_gamma_bool10!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[82] = 0.0 # Default to being off
	if (t > 28 + p[160])
		p[82] = 1.0
	end
end


function condition_gamma_bool13(u, t, integrator)
	t == integrator.p[160] + 50
end
function affect_gamma_bool13!(integrator)
	integrator.p[130] = 1.0
end
function activeAtTime0_gamma_bool13!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[130] = 0.0 # Default to being off
	if !(t ≤ p[160] + 50)
		p[130] = 1.0
	end
end


function condition_sigma_bool7(u, t, integrator)
	t == integrator.p[160] + 50
end
function affect_sigma_bool7!(integrator)
	integrator.p[37] = 1.0
end
function activeAtTime0_sigma_bool7!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[37] = 0.0 # Default to being off
	if !(t ≤ p[160] + 50)
		p[37] = 1.0
	end
end


function condition_gamma_bool2(u, t, integrator)
	t == 4 + integrator.p[160]
end
function affect_gamma_bool2!(integrator)
	integrator.p[132] = 1.0
end
function activeAtTime0_gamma_bool2!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[132] = 0.0 # Default to being off
	if (t > 4 + p[160])
		p[132] = 1.0
	end
end


function condition_alpha_bool1(u, t, integrator)
	t == 4 + integrator.p[160]
end
function affect_alpha_bool1!(integrator)
	integrator.p[38] = 1.0
end
function activeAtTime0_alpha_bool1!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[38] = 0.0 # Default to being off
	if !(t ≤ 4 + p[160])
		p[38] = 1.0
	end
end


function condition_kappa_bool9(u, t, integrator)
	t == integrator.p[160] + 50
end
function affect_kappa_bool9!(integrator)
	integrator.p[176] = 1.0
end
function activeAtTime0_kappa_bool9!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[176] = 0.0 # Default to being off
	if !(t ≤ p[160] + 50)
		p[176] = 1.0
	end
end


function condition_mu_bool4(u, t, integrator)
	t == 22 + integrator.p[160]
end
function affect_mu_bool4!(integrator)
	integrator.p[39] = 1.0
end
function activeAtTime0_mu_bool4!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[39] = 0.0 # Default to being off
	if (t > 22 + p[160])
		p[39] = 1.0
	end
end


function condition_sigma_bool8(u, t, integrator)
	t == 38 + integrator.p[160]
end
function affect_sigma_bool8!(integrator)
	integrator.p[84] = 1.0
end
function activeAtTime0_sigma_bool8!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[84] = 0.0 # Default to being off
	if (t > 38 + p[160])
		p[84] = 1.0
	end
end


function condition_nu_bool3(u, t, integrator)
	t == integrator.p[160] + 50
end
function affect_nu_bool3!(integrator)
	integrator.p[133] = 1.0
end
function activeAtTime0_nu_bool3!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[133] = 0.0 # Default to being off
	if !(t ≤ p[160] + 50)
		p[133] = 1.0
	end
end


function condition_nu_bool1(u, t, integrator)
	t == 22 + integrator.p[160]
end
function affect_nu_bool1!(integrator)
	integrator.p[40] = 1.0
end
function activeAtTime0_nu_bool1!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[40] = 0.0 # Default to being off
	if !(t ≤ 22 + p[160])
		p[40] = 1.0
	end
end


function condition_kappa_bool1(u, t, integrator)
	t == 22 + integrator.p[160]
end
function affect_kappa_bool1!(integrator)
	integrator.p[177] = 1.0
end
function activeAtTime0_kappa_bool1!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[177] = 0.0 # Default to being off
	if !(t ≤ 22 + p[160])
		p[177] = 1.0
	end
end


function condition_rho_bool8(u, t, integrator)
	t == 38 + integrator.p[160]
end
function affect_rho_bool8!(integrator)
	integrator.p[179] = 1.0
end
function activeAtTime0_rho_bool8!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[179] = 0.0 # Default to being off
	if (t > 38 + p[160])
		p[179] = 1.0
	end
end


function condition_epsilon_bool10(u, t, integrator)
	t == 50 + integrator.p[160]
end
function affect_epsilon_bool10!(integrator)
	integrator.p[86] = 1.0
end
function activeAtTime0_epsilon_bool10!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[86] = 0.0 # Default to being off
	if (t > 50 + p[160])
		p[86] = 1.0
	end
end


function condition_gamma_bool6(u, t, integrator)
	t == 22 + integrator.p[160]
end
function affect_gamma_bool6!(integrator)
	integrator.p[87] = 1.0
end
function activeAtTime0_gamma_bool6!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[87] = 0.0 # Default to being off
	if (t > 22 + p[160])
		p[87] = 1.0
	end
end


function condition_alpha_bool9(u, t, integrator)
	t == integrator.p[160] + 28
end
function affect_alpha_bool9!(integrator)
	integrator.p[182] = 1.0
end
function activeAtTime0_alpha_bool9!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[182] = 0.0 # Default to being off
	if !(t ≤ p[160] + 28)
		p[182] = 1.0
	end
end


function condition_epsilon_bool6(u, t, integrator)
	t == 38 + integrator.p[160]
end
function affect_epsilon_bool6!(integrator)
	integrator.p[134] = 1.0
end
function activeAtTime0_epsilon_bool6!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[134] = 0.0 # Default to being off
	if (t > 38 + p[160])
		p[134] = 1.0
	end
end


function condition_sigma_bool1(u, t, integrator)
	t == 22 + integrator.p[160]
end
function affect_sigma_bool1!(integrator)
	integrator.p[184] = 1.0
end
function activeAtTime0_sigma_bool1!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[184] = 0.0 # Default to being off
	if !(t ≤ 22 + p[160])
		p[184] = 1.0
	end
end


function condition_beta_bool10(u, t, integrator)
	t == 50 + integrator.p[160]
end
function affect_beta_bool10!(integrator)
	integrator.p[185] = 1.0
end
function activeAtTime0_beta_bool10!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[185] = 0.0 # Default to being off
	if (t > 50 + p[160])
		p[185] = 1.0
	end
end


function condition_xi_bool2(u, t, integrator)
	t == 22 + integrator.p[160]
end
function affect_xi_bool2!(integrator)
	integrator.p[43] = 1.0
end
function activeAtTime0_xi_bool2!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[43] = 0.0 # Default to being off
	if (t > 22 + p[160])
		p[43] = 1.0
	end
end


function condition_rho_bool5(u, t, integrator)
	t == integrator.p[160] + 38
end
function affect_rho_bool5!(integrator)
	integrator.p[44] = 1.0
end
function activeAtTime0_rho_bool5!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[44] = 0.0 # Default to being off
	if !(t ≤ p[160] + 38)
		p[44] = 1.0
	end
end


function condition_alpha_bool7(u, t, integrator)
	t == integrator.p[160] + 28
end
function affect_alpha_bool7!(integrator)
	integrator.p[187] = 1.0
end
function activeAtTime0_alpha_bool7!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[187] = 0.0 # Default to being off
	if !(t ≤ p[160] + 28)
		p[187] = 1.0
	end
end


function condition_delta_bool8(u, t, integrator)
	t == 22 + integrator.p[160]
end
function affect_delta_bool8!(integrator)
	integrator.p[135] = 1.0
end
function activeAtTime0_delta_bool8!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[135] = 0.0 # Default to being off
	if (t > 22 + p[160])
		p[135] = 1.0
	end
end


function condition_kappa_bool2(u, t, integrator)
	t == 22 + integrator.p[160]
end
function affect_kappa_bool2!(integrator)
	integrator.p[47] = 1.0
end
function activeAtTime0_kappa_bool2!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[47] = 0.0 # Default to being off
	if (t > 22 + p[160])
		p[47] = 1.0
	end
end


function condition_nu_bool2(u, t, integrator)
	t == 22 + integrator.p[160]
end
function affect_nu_bool2!(integrator)
	integrator.p[136] = 1.0
end
function activeAtTime0_nu_bool2!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[136] = 0.0 # Default to being off
	if (t > 22 + p[160])
		p[136] = 1.0
	end
end


function condition_alpha_bool3(u, t, integrator)
	t == integrator.p[160] + 22
end
function affect_alpha_bool3!(integrator)
	integrator.p[48] = 1.0
end
function activeAtTime0_alpha_bool3!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[48] = 0.0 # Default to being off
	if !(t ≤ p[160] + 22)
		p[48] = 1.0
	end
end


function condition_delta_bool4(u, t, integrator)
	t == 4 + integrator.p[160]
end
function affect_delta_bool4!(integrator)
	integrator.p[190] = 1.0
end
function activeAtTime0_delta_bool4!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[190] = 0.0 # Default to being off
	if (t > 4 + p[160])
		p[190] = 1.0
	end
end


function condition_zeta_bool1(u, t, integrator)
	t == 22 + integrator.p[160]
end
function affect_zeta_bool1!(integrator)
	integrator.p[49] = 1.0
end
function activeAtTime0_zeta_bool1!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[49] = 0.0 # Default to being off
	if !(t ≤ 22 + p[160])
		p[49] = 1.0
	end
end


function condition_eta_bool10(u, t, integrator)
	t == 50 + integrator.p[160]
end
function affect_eta_bool10!(integrator)
	integrator.p[50] = 1.0
end
function activeAtTime0_eta_bool10!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[50] = 0.0 # Default to being off
	if (t > 50 + p[160])
		p[50] = 1.0
	end
end


function condition_beta_bool6(u, t, integrator)
	t == 22 + integrator.p[160]
end
function affect_beta_bool6!(integrator)
	integrator.p[51] = 1.0
end
function activeAtTime0_beta_bool6!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[51] = 0.0 # Default to being off
	if (t > 22 + p[160])
		p[51] = 1.0
	end
end


function condition_beta_bool1(u, t, integrator)
	t == 4 + integrator.p[160]
end
function affect_beta_bool1!(integrator)
	integrator.p[53] = 1.0
end
function activeAtTime0_beta_bool1!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[53] = 0.0 # Default to being off
	if !(t ≤ 4 + p[160])
		p[53] = 1.0
	end
end


function condition_rho_bool4(u, t, integrator)
	t == 22 + integrator.p[160]
end
function affect_rho_bool4!(integrator)
	integrator.p[93] = 1.0
end
function activeAtTime0_rho_bool4!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[93] = 0.0 # Default to being off
	if (t > 22 + p[160])
		p[93] = 1.0
	end
end


function condition_xi_bool6(u, t, integrator)
	t == 38 + integrator.p[160]
end
function affect_xi_bool6!(integrator)
	integrator.p[54] = 1.0
end
function activeAtTime0_xi_bool6!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[54] = 0.0 # Default to being off
	if (t > 38 + p[160])
		p[54] = 1.0
	end
end


function condition_sigma_bool10(u, t, integrator)
	t == 50 + integrator.p[160]
end
function affect_sigma_bool10!(integrator)
	integrator.p[192] = 1.0
end
function activeAtTime0_sigma_bool10!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[192] = 0.0 # Default to being off
	if (t > 50 + p[160])
		p[192] = 1.0
	end
end


function condition_sigma_bool6(u, t, integrator)
	t == 38 + integrator.p[160]
end
function affect_sigma_bool6!(integrator)
	integrator.p[139] = 1.0
end
function activeAtTime0_sigma_bool6!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[139] = 0.0 # Default to being off
	if (t > 38 + p[160])
		p[139] = 1.0
	end
end


function condition_alpha_bool2(u, t, integrator)
	t == 4 + integrator.p[160]
end
function affect_alpha_bool2!(integrator)
	integrator.p[140] = 1.0
end
function activeAtTime0_alpha_bool2!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[140] = 0.0 # Default to being off
	if (t > 4 + p[160])
		p[140] = 1.0
	end
end


function condition_zeta_bool3(u, t, integrator)
	t == integrator.p[160] + 38
end
function affect_zeta_bool3!(integrator)
	integrator.p[138] = 1.0
end
function activeAtTime0_zeta_bool3!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[138] = 0.0 # Default to being off
	if !(t ≤ p[160] + 38)
		p[138] = 1.0
	end
end


function condition_epsilon_bool2(u, t, integrator)
	t == 12 + integrator.p[160]
end
function affect_epsilon_bool2!(integrator)
	integrator.p[92] = 1.0
end
function activeAtTime0_epsilon_bool2!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[92] = 0.0 # Default to being off
	if (t > 12 + p[160])
		p[92] = 1.0
	end
end


function condition_beta_bool5(u, t, integrator)
	t == integrator.p[160] + 22
end
function affect_beta_bool5!(integrator)
	integrator.p[141] = 1.0
end
function activeAtTime0_beta_bool5!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[141] = 0.0 # Default to being off
	if !(t ≤ p[160] + 22)
		p[141] = 1.0
	end
end


function condition_gamma_bool9(u, t, integrator)
	t == integrator.p[160] + 28
end
function affect_gamma_bool9!(integrator)
	integrator.p[56] = 1.0
end
function activeAtTime0_gamma_bool9!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[56] = 0.0 # Default to being off
	if !(t ≤ p[160] + 28)
		p[56] = 1.0
	end
end


function condition_gamma_bool12(u, t, integrator)
	t == 28 + integrator.p[160]
end
function affect_gamma_bool12!(integrator)
	integrator.p[191] = 1.0
end
function activeAtTime0_gamma_bool12!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[191] = 0.0 # Default to being off
	if (t > 28 + p[160])
		p[191] = 1.0
	end
end


function condition_mu_bool5(u, t, integrator)
	t == integrator.p[160] + 50
end
function affect_mu_bool5!(integrator)
	integrator.p[94] = 1.0
end
function activeAtTime0_mu_bool5!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[94] = 0.0 # Default to being off
	if !(t ≤ p[160] + 50)
		p[94] = 1.0
	end
end


function condition_lam_bool3(u, t, integrator)
	t == integrator.p[160] + 50
end
function affect_lam_bool3!(integrator)
	integrator.p[57] = 1.0
end
function activeAtTime0_lam_bool3!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[57] = 0.0 # Default to being off
	if !(t ≤ p[160] + 50)
		p[57] = 1.0
	end
end


function condition_sigma_bool4(u, t, integrator)
	t == 22 + integrator.p[160]
end
function affect_sigma_bool4!(integrator)
	integrator.p[193] = 1.0
end
function activeAtTime0_sigma_bool4!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[193] = 0.0 # Default to being off
	if (t > 22 + p[160])
		p[193] = 1.0
	end
end


function condition_xi_bool1(u, t, integrator)
	t == 22 + integrator.p[160]
end
function affect_xi_bool1!(integrator)
	integrator.p[58] = 1.0
end
function activeAtTime0_xi_bool1!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[58] = 0.0 # Default to being off
	if !(t ≤ 22 + p[160])
		p[58] = 1.0
	end
end


function condition_alpha_bool5(u, t, integrator)
	t == integrator.p[160] + 22
end
function affect_alpha_bool5!(integrator)
	integrator.p[194] = 1.0
end
function activeAtTime0_alpha_bool5!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[194] = 0.0 # Default to being off
	if !(t ≤ p[160] + 22)
		p[194] = 1.0
	end
end


function condition_delta_bool6(u, t, integrator)
	t == 22 + integrator.p[160]
end
function affect_delta_bool6!(integrator)
	integrator.p[142] = 1.0
end
function activeAtTime0_delta_bool6!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[142] = 0.0 # Default to being off
	if (t > 22 + p[160])
		p[142] = 1.0
	end
end


function condition_sigma_bool9(u, t, integrator)
	t == integrator.p[160] + 50
end
function affect_sigma_bool9!(integrator)
	integrator.p[95] = 1.0
end
function activeAtTime0_sigma_bool9!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[95] = 0.0 # Default to being off
	if !(t ≤ p[160] + 50)
		p[95] = 1.0
	end
end


function condition_alpha_bool13(u, t, integrator)
	t == integrator.p[160] + 50
end
function affect_alpha_bool13!(integrator)
	integrator.p[195] = 1.0
end
function activeAtTime0_alpha_bool13!(u, p)
	t = 0.0 # Used to check conditions activated at t0=0
	p[195] = 0.0 # Default to being off
	if !(t ≤ p[160] + 50)
		p[195] = 1.0
	end
end

function getTstops(u, p)
	 return [dualToFloat((50//1) + p[160]), dualToFloat((22//1) + p[160]), dualToFloat((28//1) + p[160]), dualToFloat((4//1) + p[160]), dualToFloat((12//1) + p[160]), dualToFloat((38//1) + p[160]), dualToFloat((38//1) + p[160]), dualToFloat((22//1) + p[160]), dualToFloat((38//1) + p[160]), dualToFloat((50//1) + p[160]), dualToFloat((50//1) + p[160]), dualToFloat((22//1) + p[160]), dualToFloat((38//1) + p[160]), dualToFloat((50//1) + p[160]), dualToFloat((38//1) + p[160]), dualToFloat((22//1) + p[160]), dualToFloat((22//1) + p[160]), dualToFloat((22//1) + p[160]), dualToFloat((22//1) + p[160]), dualToFloat((22//1) + p[160]), dualToFloat((38//1) + p[160]), dualToFloat((22//1) + p[160]), dualToFloat((50//1) + p[160]), dualToFloat((50//1) + p[160]), dualToFloat((22//1) + p[160]), dualToFloat((4//1) + p[160]), dualToFloat((4//1) + p[160]), dualToFloat((4//1) + p[160]), dualToFloat((22//1) + p[160]), dualToFloat((22//1) + p[160]), dualToFloat((38//1) + p[160]), dualToFloat((50//1) + p[160]), dualToFloat((50//1) + p[160]), dualToFloat((38//1) + p[160]), dualToFloat((4//1) + p[160]), dualToFloat((22//1) + p[160]), dualToFloat((50//1) + p[160]), dualToFloat((50//1) + p[160]), dualToFloat((50//1) + p[160]), dualToFloat((50//1) + p[160]), dualToFloat((22//1) + p[160]), dualToFloat((38//1) + p[160]), dualToFloat((50//1) + p[160]), dualToFloat((22//1) + p[160]), dualToFloat((38//1) + p[160]), dualToFloat((22//1) + p[160]), dualToFloat((38//1) + p[160]), dualToFloat((50//1) + p[160]), dualToFloat((4//1) + p[160]), dualToFloat((50//1) + p[160]), dualToFloat((4//1) + p[160]), dualToFloat((38//1) + p[160]), dualToFloat((50//1) + p[160]), dualToFloat((38//1) + p[160]), dualToFloat((50//1) + p[160]), dualToFloat((38//1) + p[160]), dualToFloat((50//1) + p[160]), dualToFloat((50//1) + p[160]), dualToFloat((22//1) + p[160]), dualToFloat((50//1) + p[160]), dualToFloat((22//1) + p[160]), dualToFloat((38//1) + p[160]), dualToFloat((50//1) + p[160]), dualToFloat((22//1) + p[160]), dualToFloat((22//1) + p[160]), dualToFloat((38//1) + p[160]), dualToFloat((22//1) + p[160]), dualToFloat((50//1) + p[160]), dualToFloat((50//1) + p[160]), dualToFloat((38//1) + p[160]), dualToFloat((22//1) + p[160]), dualToFloat((50//1) + p[160]), dualToFloat((50//1) + p[160]), dualToFloat((38//1) + p[160]), dualToFloat((12//1) + p[160]), dualToFloat((50//1) + p[160]), dualToFloat((50//1) + p[160]), dualToFloat((38//1) + p[160]), dualToFloat((22//1) + p[160]), dualToFloat((22//1) + p[160]), dualToFloat((22//1) + p[160]), dualToFloat((50//1) + p[160]), dualToFloat((50//1) + p[160]), dualToFloat((38//1) + p[160]), dualToFloat((28//1) + p[160]), dualToFloat((50//1) + p[160]), dualToFloat((28//1) + p[160]), dualToFloat((38//1) + p[160]), dualToFloat((28//1) + p[160]), dualToFloat((50//1) + p[160]), dualToFloat((50//1) + p[160]), dualToFloat((4//1) + p[160]), dualToFloat((4//1) + p[160]), dualToFloat((50//1) + p[160]), dualToFloat((22//1) + p[160]), dualToFloat((38//1) + p[160]), dualToFloat((50//1) + p[160]), dualToFloat((22//1) + p[160]), dualToFloat((22//1) + p[160]), dualToFloat((38//1) + p[160]), dualToFloat((50//1) + p[160]), dualToFloat((22//1) + p[160]), dualToFloat((28//1) + p[160]), dualToFloat((38//1) + p[160]), dualToFloat((22//1) + p[160]), dualToFloat((50//1) + p[160]), dualToFloat((22//1) + p[160]), dualToFloat((38//1) + p[160]), dualToFloat((28//1) + p[160]), dualToFloat((22//1) + p[160]), dualToFloat((22//1) + p[160]), dualToFloat((22//1) + p[160]), dualToFloat((22//1) + p[160]), dualToFloat((4//1) + p[160]), dualToFloat((22//1) + p[160]), dualToFloat((50//1) + p[160]), dualToFloat((22//1) + p[160]), dualToFloat((4//1) + p[160]), dualToFloat((22//1) + p[160]), dualToFloat((38//1) + p[160]), dualToFloat((50//1) + p[160]), dualToFloat((38//1) + p[160]), dualToFloat((4//1) + p[160]), dualToFloat((38//1) + p[160]), dualToFloat((12//1) + p[160]), dualToFloat((22//1) + p[160]), dualToFloat((28//1) + p[160]), dualToFloat((28//1) + p[160]), dualToFloat((50//1) + p[160]), dualToFloat((50//1) + p[160]), dualToFloat((22//1) + p[160]), dualToFloat((22//1) + p[160]), dualToFloat((22//1) + p[160]), dualToFloat((22//1) + p[160]), dualToFloat((50//1) + p[160]), dualToFloat((50//1) + p[160])]
end